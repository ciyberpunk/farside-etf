<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Farside ETF Flows</title>
  <style>
    :root { 
      --bg: #0e0f12; 
      --panel: #15171c; 
      --text: #e9eef5; 
      --muted: #a7b0bc; 
      --accent: #3aa3ff;
      --good: #1f77b4; /* inflow (blue) */
      --bad:  #d62728; /* outflow (red) */
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .wrap { max-width: 1100px; margin: 32px auto 80px; padding: 0 16px; }
    header { margin-bottom: 18px; }
    h1 { margin: 0 0 6px; font-size: 1.6rem; font-weight: 650; }
    p.note { margin: 4px 0 18px; color: var(--muted); font-size: 0.95rem; }
    .panel {
      background: var(--panel);
      border: 1px solid #23262d;
      border-radius: 14px;
      padding: 16px 16px 8px;
      margin-bottom: 18px;
      box-shadow: 0 1px 0 rgba(255,255,255,0.03), 0 12px 30px rgba(0,0,0,0.35);
    }
    .chart-wrap { position: relative; height: 420px; }
    .title-row { display: flex; align-items: baseline; justify-content: space-between; gap: 12px; margin: 0 2px 8px; }
    .title-row h2 { margin: 0; font-size: 1.1rem; font-weight: 600; }
    .err { color: #ff8c99; font-size: 0.9rem; margin-top: 6px; display: none; }
    a, a:visited { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    footer { margin-top: 26px; color: var(--muted); font-size: 0.9rem; }
  </style>
  <!-- Chart.js + time adapter -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Spot ETF Flows — Daily (bars) &amp; Cumulative (line)</h1>
      <p class="note">Bars show daily net flow (USD&nbsp;mm) on the <b>right</b> axis. Line shows cumulative total (rebased to 0 at first day) on the <b>left</b> axis. Zero lines are pixel-aligned.</p>
    </header>

    <section class="panel">
      <div class="title-row">
        <h2>Bitcoin</h2>
        <small><a href="https://github.com/ciyberpunk/farside-etf/tree/main/Data" target="_blank" rel="noopener">CSV source</a></small>
      </div>
      <div class="chart-wrap"><canvas id="btcChart"></canvas></div>
      <div id="btcErr" class="err"></div>
    </section>

    <section class="panel">
      <div class="title-row">
        <h2>Ethereum</h2>
        <small><a href="https://github.com/ciyberpunk/farside-etf/tree/main/Data" target="_blank" rel="noopener">CSV source</a></small>
      </div>
      <div class="chart-wrap"><canvas id="ethChart"></canvas></div>
      <div id="ethErr" class="err"></div>
    </section>

    <footer>
      Tip: Hard-refresh if needed (<kbd>Cmd/Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>R</kbd>). Fetches include a cache-buster.
    </footer>
  </div>

  <script>
    const CSV_BTC = "Data/bitcoin_etf_totals_daily.csv";
    const CSV_ETH = "Data/ethereum_etf_totals_daily.csv";

    function parseCSV(text) {
      const lines = text.trim().split(/\r?\n/);
      if (!lines.length) return { header: [], rows: [] };
      const header = lines[0].split(",").map(s => s.trim());
      const rows = lines.slice(1).map(line => line.split(",").map(s => s.trim()));
      return { header, rows };
    }

    function coerceNumber(s) {
      if (s == null) return NaN;
      const t = s.replace(/[\u2009\u00A0,]/g, "").replace(/^\((.*)\)$/, "-$1");
      const n = Number(t);
      return Number.isFinite(n) ? n : NaN;
    }

    async function loadTotalsCsv(url) {
      const bust = `v=${Date.now()}`;
      const resp = await fetch(url + (url.includes("?") ? "&" : "?") + bust, { cache: "no-store" });
      if (!resp.ok) throw new Error("HTTP " + resp.status + " for " + url);
      const text = await resp.text();
      const { header, rows } = parseCSV(text);

      const idx = Object.fromEntries(header.map((h, i) => [h.toLowerCase(), i]));
      const iDate  = idx["date"];
      const iTotal = idx["total_usd_millions"] ?? idx["total"];
      const iCum   = idx["cumulative_usd_millions"];
      if (iDate == null || iTotal == null) {
        throw new Error("Required columns not found: " + header.join(", "));
      }

      const dates = [], totals = [], cumAbs = [];
      let running = 0;
      for (const r of rows) {
        const d = new Date(r[iDate]);
        if (Number.isNaN(d.getTime())) continue;
        const t = coerceNumber(r[iTotal]);
        if (!Number.isFinite(t)) continue;
        dates.push(d);
        totals.push(t);
        if (iCum != null) {
          const c = coerceNumber(r[iCum]);
          cumAbs.push(Number.isFinite(c) ? c : NaN);
        } else {
          running += t;
          cumAbs.push(running);
        }
      }
      // Rebase cumulative: first finite point -> 0
      const first = cumAbs.find(v => Number.isFinite(v));
      const cum = first == null ? cumAbs.slice() : cumAbs.map(v => Number.isFinite(v) ? v - first : NaN);

      return { dates, totals, cum };
    }

    // Build left-axis bounds so zero aligns with right-axis zero pixel.
    function alignedScalesFor(series) {
      // Right axis (bars) data bounds with padding
      const minRdata = Math.min(0, ...series.totals);
      const maxRdata = Math.max(0, ...series.totals);
      let spanR = maxRdata - minRdata;
      if (!Number.isFinite(spanR) || spanR === 0) { // all zeros?
        return {
          y:  { min: -1, max: 1 },  // left
          y2: { min: -1, max: 1 }   // right
        };
      }
      const padR = 0.08 * spanR;
      const minR = minRdata - padR;
      const maxR = maxRdata + padR;

      // Fractional position of zero on the right axis (0..1 from bottom)
      const r = (0 - minR) / (maxR - minR);

      // Left axis must contain cumulative (rebased) data and place zero at same fraction r
      const finite = series.cum.filter(Number.isFinite);
      if (!finite.length) {
        return { y: {}, y2: { min: minR, max: maxR } };
      }
      const minLdata = Math.min(0, ...finite);
      const maxLdata = Math.max(0, ...finite);

      // Guard against r near 0 or 1 (avoid huge spans)
      if (r <= 0.02 || r >= 0.98) {
        return { y: {}, y2: { min: minR, max: maxR } };
      }

      // Choose span S so that:
      //   distance below zero = r*S >= |minLdata|
      //   distance above zero = (1 - r)*S >= maxLdata
      const SreqNeg = Math.abs(minLdata) / r;
      const SreqPos = (maxLdata) / (1 - r);
      let S = Math.max(SreqNeg, SreqPos);
      S *= 1.05; // small pad

      const minL = -r * S;
      const maxL = (1 - r) * S;

      return {
        y:  { min: minL, max: maxL },
        y2: { min: minR, max: maxR }
      };
    }

    function makeChart(canvasId, series, titleText) {
      const ctx = document.getElementById(canvasId).getContext("2d");
      const pos = series.totals.map(v => Math.max(0, v));
      const neg = series.totals.map(v => Math.min(0, v));

      const scalesAligned = alignedScalesFor(series);

      return new Chart(ctx, {
        data: {
          labels: series.dates,
          datasets: [
            // LEFT axis: cumulative (rebased)
            {
              type: "line",
              label: "Cumulative (rebased)",
              data: series.cum,
              borderColor: "#ffffff",
              borderWidth: 2,
              pointRadius: 0,
              yAxisID: "y",
              spanGaps: true
            },
            // RIGHT axis: daily bars
            {
              type: "bar",
              label: "Daily inflow",
              data: pos,
              backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--good').trim() || "#1f77b4",
              borderWidth: 0,
              yAxisID: "y2"
            },
            {
              type: "bar",
              label: "Daily outflow",
              data: neg,
              backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--bad').trim() || "#d62728",
              borderWidth: 0,
              yAxisID: "y2"
            }
          ]
        },
        options: {
          maintainAspectRatio: false,
          interaction: { mode: "index", intersect: false },
          scales: {
            x: {
              type: "time",
              time: { unit: "month" },
              ticks: { color: "#c7cfdb" },
              grid: { color: "rgba(255,255,255,0.08)" }
            },
            y: {
              position: "left",
              title: { text: "USD (millions) - cumulative (rebased)", display: true, color: "#c7cfdb" },
              ticks: { color: "#c7cfdb" },
              grid: { color: "rgba(255,255,255,0.08)" },
              ...scalesAligned.y
            },
            y2: {
              position: "right",
              title: { text: "USD (millions) - daily", display: true, color: "#c7cfdb" },
              ticks: { color: "#c7cfdb" },
              grid: { drawOnChartArea: false },
              ...scalesAligned.y2
            }
          },
          plugins: {
            legend: { labels: { color: "#e9eef5" } },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  const val = ctx.parsed.y;
                  return ` ${ctx.dataset.label}: ${val.toLocaleString(undefined, { maximumFractionDigits: 1 })}`;
                }
              }
            },
            title: {
              display: true,
              text: titleText,
              color: "#e9eef5",
              font: { weight: "600", size: 14 }
            }
          }
        }
      });
    }

    async function init() {
      try {
        const btc = await loadTotalsCsv(CSV_BTC);
        makeChart("btcChart", btc, "BTC spot ETF — cumulative (left) & daily (right)");
      } catch (e) {
        const el = document.getElementById("btcErr");
        el.textContent = e.message;
        el.style.display = "block";
        console.error(e);
      }
      try {
        const eth = await loadTotalsCsv(CSV_ETH);
        makeChart("ethChart", eth, "ETH spot ETF — cumulative (left) & daily (right)");
      } catch (e) {
        const el = document.getElementById("ethErr");
        el.textContent = e.message;
        el.style.display = "block";
        console.error(e);
      }
    }
    init();
  </script>
</body>
</html>
