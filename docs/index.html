<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Farside ETF Flows — BTC & ETH</title>
  <style>
    :root { --bg: #ffffff; --fg: #111111; }
    html, body { margin:0; padding:0; background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    header { padding: 16px 20px; border-bottom: 1px solid #eee; }
    main { padding: 20px; max-width: 1100px; margin: 0 auto; }
    h1 { font-size: 20px; margin: 0; }
    .panel { margin: 26px 0; }
    .panel h2 { font-size: 16px; font-weight: 600; margin: 0 0 10px; }
    canvas { width: 100%; height: 420px; max-height: 60vh; }
    .footnote { color:#666; font-size: 12px; margin-top: 6px; }
  </style>
  <!-- Chart.js + date adapter -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
  <header>
    <h1>Farside Spot ETF Flows — BTC & ETH</h1>
  </header>

  <main>
    <div class="panel">
      <h2>Bitcoin — daily flows (bars) & cumulative (line)</h2>
      <canvas id="btcChart"></canvas>
      <div class="footnote">Daily bars: inflow (blue) / outflow (red). Line: cumulative net flows (right axis).</div>
    </div>

    <div class="panel">
      <h2>Ethereum — daily flows (bars) & cumulative (line)</h2>
      <canvas id="ethChart"></canvas>
      <div class="footnote">Daily bars: inflow (blue) / outflow (red). Line: cumulative net flows (right axis).</div>
    </div>
  </main>

  <script>
    // ---- helpers ----
    const nf1 = new Intl.NumberFormat("en-US", { maximumFractionDigits: 1 });
    const nf0 = new Intl.NumberFormat("en-US", { maximumFractionDigits: 0 });

    // Build a BASE so it works locally and on GitHub Pages (/farside-etf)
    const BASE = window.location.pathname
      .replace(/\/index\.html?$/i, "")
      .replace(/\/$/, "");

    async function fetchCSV(path) {
      const res = await fetch(path);
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${path}`);
      return await res.text();
    }

    // very small CSV parser (assumes simple CSV without commas inside fields – which matches our generator)
    function parseCSV(text) {
      const lines = text.trim().split(/\r?\n/);
      if (lines.length === 0) return [];
      const headers = lines[0].split(",").map(h => h.trim().toLowerCase());
      return lines.slice(1).map(line => {
        const cols = line.split(","); // safe given our CSV content
        const row = {};
        headers.forEach((h, i) => row[h] = (cols[i] ?? "").trim());
        return row;
      });
    }

    function coerceNumber(x) {
      if (x == null || x === "") return null;
      const n = Number(x);
      return Number.isFinite(n) ? n : null;
    }

    function toDateStrict(s) {
      // CSV is YYYY-MM-DD from our Python scripts
      // new Date('YYYY-MM-DD') is parsed as UTC by modern browsers; that’s fine for daily charts.
      const d = new Date(s);
      return isNaN(+d) ? null : d;
    }

    function buildSeries(rows) {
      // Normalize keys (lowercase)
      // Expect: date, total_usd_millions, cumulative_usd_millions
      const norm = rows.map(r => ({
        date: toDateStrict(r.date ?? r["Date"]),
        total: coerceNumber(r.total_usd_millions ?? r.total ?? r["Total"]),
        cumulative: coerceNumber(r.cumulative_usd_millions ?? r.cumulative ?? r["Cumulative"])
      })).filter(r => r.date && r.total !== null);

      // Sort ASCENDING by date so cumulative starts at the first day.
      norm.sort((a, b) => a.date - b.date);

      // If cumulative missing in CSV, compute it here (ascending)
      if (norm.length && (norm[0].cumulative === null || norm.some(r => r.cumulative === null))) {
        let run = 0;
        for (const r of norm) {
          run += r.total;
          r.cumulative = run;
        }
      }

      return norm;
    }

    function makeChart(canvasId, series, titleText) {
      const ctx = document.getElementById(canvasId).getContext("2d");

      const labels = series.map(r => r.date);
      const daily = series.map(r => r.total);
      const dailyPos = daily.map(v => (v > 0 ? v : 0));
      const dailyNeg = daily.map(v => (v < 0 ? v : 0));
      const cum = series.map(r => r.cumulative);

      return new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [
            {
              type: "bar",
              label: "Inflow (daily)",
              data: dailyPos,
              xAxisID: "x",
              yAxisID: "yDaily",
              backgroundColor: "#1f77b4"
            },
            {
              type: "bar",
              label: "Outflow (daily)",
              data: dailyNeg,
              xAxisID: "x",
              yAxisID: "yDaily",
              backgroundColor: "#d62728"
            },
            {
              type: "line",
              label: "Cumulative",
              data: cum,
              xAxisID: "x",
              yAxisID: "yCum",
              borderColor: "#111111",
              backgroundColor: "transparent",
              borderWidth: 2,
              pointRadius: 0,
              tension: 0.1
            }
          ]
        },
        options: {
          responsive: true,
          interaction: {
            mode: "index",
            intersect: false
          },
          plugins: {
            title: {
              display: true,
              text: titleText
            },
            tooltip: {
              callbacks: {
                // show the correct y for each dataset (Chart.js gives us that in parsed.y)
                label: (ctx) => {
                  const v = ctx.parsed.y;
                  const label = ctx.dataset.label || "";
                  // pretty-print with one decimal and explicit sign for daily bars
                  if (label.includes("Inflow") || label.includes("Outflow")) {
                    const pretty = (v >= 0 ? "+" : "") + nf1.format(v) + " M";
                    return `${label}: ${pretty}`;
                  }
                  // cumulative
                  return `${label}: ${nf1.format(v)} M`;
                }
              }
            },
            legend: {
              position: "top"
            }
          },
          scales: {
            x: {
              type: "time",
              time: { unit: "month" },
              ticks: { maxRotation: 0, autoSkip: true }
            },
            yDaily: {
              position: "left",
              title: { display: true, text: "USD millions (daily)" },
              grid: { drawOnChartArea: true }
            },
            yCum: {
              position: "right",
              title: { display: true, text: "USD millions (cumulative)" },
              grid: { drawOnChartArea: false }
            }
          }
        }
      });
    }

    async function loadAndPlot(canvasId, csvRelPath, titleText) {
      const fullPath = `${BASE}/${csvRelPath}`.replace(/\/+/g, "/");
      try {
        const text = await fetchCSV(fullPath);
        const rows = parseCSV(text);
        const series = buildSeries(rows);
        if (!series.length) throw new Error("No rows after parsing.");
        makeChart(canvasId, series, titleText);
      } catch (err) {
        console.error(err);
        alert(`Failed to load ${csvRelPath}: ${err.message}`);
      }
    }

    // kick off both charts
    loadAndPlot("btcChart", "Data/bitcoin_etf_totals_daily.csv", "BTC spot ETF — daily flows & cumulative");
    loadAndPlot("ethChart", "Data/ethereum_etf_totals_daily.csv", "ETH spot ETF — daily flows & cumulative");
  </script>
</body>
</html>
